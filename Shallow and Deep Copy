First, we note that assignment in python does not copy -- it simply a variable to a target for objects that are mutable, or contain mutable items, a copy is needed if we want to change the copy without changing the original. Example like A =[1,2,4,8] assign A to B i.e B=A, then if we change B, Example B.append(16), then A will also change.
    two ways of copying 1.shallow  2.deep
    These are implemented in the copy module, specifically as copy.copy(x) and copy.deepcopy(x). A shallow copy constructs a new compound object and then insertes referneces into it to the objects to found in the original.A deep copy constructs a new compound object and then recursively insertes copies into it of the objects found in the original.
    As a concrete example, suppose A =[[1,2,3],[4,5,6]] and B = copy.copy(A). Then if we update B as B[0][0] = 0, A[0][0] also changes to 0. If B =copy.deepcopy(A),then the same update will leave A unchanged.
    The difference betwenn shallow and deep copying is only relevant for compound objects, that is objects that contain other objects, such as lists or class instances. If A =[1,2,3] and B=copy.copy(A) then if we update B as B[0] =0 , A is uncahnged
    Diving under the hood, deep copy is more challenging to implement since recursive objects compound objects that directly or indirectly contain a reference to themselves result in infinite recursion in a native implementation of deep copy. Since a deep copy copies every-thing it may copy too much book-keeping data strucutres that should be shared even between copies. 
        The copy.deepcopy() function avoids these problems by caching objects already copied, and letting user-defined classes override the coyping operation.In paticular a class can override one or both of__copy__()and __deepcopy__()